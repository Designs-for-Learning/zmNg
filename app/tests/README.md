# Testing Guide for zmNg

This guide explains the BDD-first E2E testing approach for zmNg, where Gherkin feature files serve as the primary source of truth for all tests.

## Table of Contents

1. [Overview](#overview)
2. [BDD-First Workflow](#bdd-first-workflow)
3. [Running Tests](#running-tests)
4. [Writing Tests](#writing-tests)
5. [Test Organization](#test-organization)
6. [Best Practices](#best-practices)

## Overview

The zmNg testing framework uses a **BDD-first approach** where all E2E tests are generated from Gherkin feature files:

1. **Gherkin Feature Files** (Source of Truth) - Human-readable scenarios using Given/When/Then syntax
2. **Step Definitions** - JavaScript/TypeScript implementations of each Gherkin step
3. **Generated Tests** - Playwright tests automatically generated by playwright-bdd
4. **Test Plans** (Optional) - Detailed markdown specifications for complex features

All tests rely on `data-testid` attributes for reliable element selection.

### BDD-First Philosophy

**Entry Point: Gherkin** → **Step Definitions** → **Generated Tests** → **Test Execution**

- Write feature files first in plain English
- Implement step definitions to execute the steps
- playwright-bdd generates .spec.ts files automatically
- Run generated tests with standard Playwright commands

## BDD-First Workflow

### Step 1: Write Gherkin Feature Files

Create `.feature` files in `tests/features/` using Gherkin syntax:

**Example:** `tests/features/full-app-walkthrough.feature`
```gherkin
Feature: Full Application Walkthrough
  As a ZoneMinder user
  I want to navigate through all application screens
  So that I can verify the application works correctly

  Background:
    Given I am logged into zmNg

  Scenario: Dashboard - Add and verify widget
    When I navigate to the "Dashboard" page
    Then I should see the page heading "Dashboard"
    When I open the Add Widget dialog
    And I select the "Timeline" widget type
    And I enter widget title "Test Timeline"
    And I click the Add button in the dialog
    Then the widget "Test Timeline" should appear on the dashboard

  Scenario: Monitors - View and interact
    When I navigate to the "Monitors" page
    Then I should see at least 1 monitor cards
    When I click into the first monitor detail page
    Then I should see the monitor player
```

### Step 2: Implement Step Definitions

Create step implementations in `tests/steps.ts` using `createBdd()`:

**Example:** `tests/steps.ts`
```typescript
import { createBdd } from 'playwright-bdd';
import { expect } from '@playwright/test';

const { Given, When, Then } = createBdd();

// Authentication
Given('I am logged into zmNg', async ({ page }) => {
  await page.goto('/', { waitUntil: 'domcontentloaded' });
  await page.waitForURL(/.*(dashboard|monitors)/, { timeout: 5000 });
});

// Navigation
When('I navigate to the {string} page', async ({ page }, pageName: string) => {
  const pageRoutes: Record<string, string> = {
    'Dashboard': 'dashboard',
    'Monitors': 'monitors',
  };
  const route = pageRoutes[pageName];
  await page.getByRole('link', { name: new RegExp(`^${pageName}$`, 'i') }).click();
  await page.waitForURL(new RegExp(`.*${route}`));
});

// Assertions
Then('I should see at least {int} monitor cards', async ({ page }, count: number) => {
  const monitorCards = page.getByTestId('monitor-card');
  const actualCount = await monitorCards.count();
  expect(actualCount).toBeGreaterThanOrEqual(count);
});
```

### Step 3: Generate Tests

Run playwright-bdd to generate .spec.ts files from feature files:

```bash
npm run test:e2e:bdd
```

This command:
1. Runs `bddgen -c playwright-bdd.config.ts` to generate test files
2. Executes the generated tests with Playwright
3. Generates HTML reports with detailed results

**Generated files are created in `.features-gen/` and should not be manually edited.**

### Step 4: Run Tests

Execute the generated BDD tests:

```bash
# Run all BDD tests
npm run test:e2e:bdd

# Run with UI mode
npm run test:e2e:bdd:ui

# Run only generation (no execution)
npx bddgen -c playwright-bdd.config.ts
```

### 2. Test Plans (Markdown Specifications)

Test plans provide detailed step-by-step instructions that bridge human understanding and code implementation.

**Example:** `tests/test-plans/monitor-management.md`

Each test plan includes:
- Purpose and description
- Prerequisites
- Detailed steps with expected results
- Code examples for implementation
- Error scenarios to consider

**Template:** Use `tests/test-plans/TEMPLATE.md` as a starting point.

### 3. Structured Tests with test.step()

Enhanced Playwright tests use `test.step()` to create clear, readable test flows that appear in test reports.

**Example:** `tests/full_walkthrough_enhanced.spec.ts`
```typescript
test('Monitors: View monitor list', async () => {
  await test.step('Navigate to Monitors page', async () => {
    await page.getByRole('link', { name: /^Monitors$/i }).click();
    await page.waitForURL(/.*monitors/);
  });

  await test.step('Verify page loaded correctly', async () => {
    await expect(page.getByRole('heading', { name: /monitor/i }).first()).toBeVisible();
  });

  await test.step('Verify monitor cards are displayed', async () => {
    const monitorCards = page.getByTestId('monitor-card');
    const count = await monitorCards.count();
    expect(count).toBeGreaterThan(0);
  });
});
```

**Benefits:**
- Each step appears in test reports
- Easy to identify where tests fail
- Self-documenting test flow
- Better debugging experience

## Running Tests

### BDD Tests (Primary Method)

```bash
# Generate and run all BDD tests
npm run test:e2e:bdd

# Run with interactive UI mode
npm run test:e2e:bdd:ui

# Generate tests only (no execution)
npx bddgen -c playwright-bdd.config.ts

# View available steps
npx bddgen export -c playwright-bdd.config.ts
```

### Standard Playwright Tests (Legacy)

```bash
# Run all Playwright tests
npx playwright test

# Run specific test file
npx playwright test tests/full_walkthrough.spec.ts

# Run with UI mode
npx playwright test --ui

# Debug tests
npx playwright test --debug

# View last test report
npx playwright show-report
```

## Configuration

Configure your ZoneMinder server in `.env`:

```env
ZM_HOST_1=<url>
ZM_USER_1=<username>
ZM_PASSWORD_1=<password>
```

Timeout settings configured in `helpers/config.ts`:
- **Overall test**: 30s per test case
- **Page transitions**: 5s max per navigation
- **Element visibility**: 5s max per element

## Writing Tests

### 1. Using data-testid Attributes

All tests should use `data-testid` attributes for element selection. See `tests/test-plans/data-testid-guide.md` for complete documentation.

**Naming Convention:** Use kebab-case
- `monitor-card` - Monitor card component
- `monitor-name` - Monitor name element
- `event-list` - Events list container

**Priority Components:**

**Phase 1 (Implemented):**
- Monitor Card: `monitor-card`, `monitor-name`, `monitor-status`, `monitor-player`
- Monitors Page: `monitor-grid`, `monitors-empty-state`
- Event Card: `event-card`, `event-monitor-name`, `event-thumbnail`
- Events Page: `event-list`, `events-empty-state`

**Phase 2 (Implemented):**
- Profiles: `profile-list`, `profile-card`, `profile-name`, `profile-active-indicator`
- Logs: `log-entries`, `log-entry`, `logs-empty-state`

**Phase 3 (Future):**
- Event Detail: `event-video-player`, `event-metadata`, `event-play-button`
- Dashboard: `dashboard-grid`, `add-widget-button`, `dashboard-widget`
- Settings: `settings-section`, `theme-toggle`

### 2. Creating Gherkin Features and Steps

**Step 1: Create a feature file** in `tests/features/`

Follow the Gherkin syntax:
- `Feature:` High-level description
- `Background:` Common setup steps (run before each scenario)
- `Scenario:` Individual test case
- `Given`, `When`, `Then`, `And` - Test steps

**Step 2: Implement step definitions** in `tests/steps.ts`

Use `createBdd()` to define steps:

```typescript
// tests/steps.ts
import { createBdd } from 'playwright-bdd';
import { expect } from '@playwright/test';

const { Given, When, Then } = createBdd();

// Preconditions
Given('I have a precondition', async ({ page }) => {
  // Setup code
  await page.goto('/setup');
});

// Actions
When('I perform an action', async ({ page }) => {
  // Action code
  await page.getByRole('button', { name: 'Submit' }).click();
});

// Assertions
Then('I should see the result', async ({ page }) => {
  // Verification code
  await expect(page.getByText('Success')).toBeVisible();
});
```

**Step 3: Generate and run tests**

```bash
npm run test:e2e:bdd
```

### 3. Writing Test Plans

1. Copy `tests/test-plans/TEMPLATE.md`
2. Fill in all sections:
   - Purpose
   - Prerequisites
   - Detailed test steps
   - Expected final state
   - Error scenarios
3. Include code examples for complex interactions
4. Link to related tests

### 4. Creating Structured Tests

```typescript
test('Feature: Descriptive name', async () => {
  await test.step('Setup: Prepare environment', async () => {
    // Setup code
  });

  await test.step('Action: Perform main action', async () => {
    // Action code
  });

  await test.step('Verify: Check results', async () => {
    // Assertions
  });
});
```

## Test Organization

```
tests/
├── features/              # Gherkin feature files (SOURCE OF TRUTH)
│   ├── full-app-walkthrough.feature  # Main app walkthrough
│   └── .archive/          # Archived features
├── steps.ts               # BDD step definitions (createBdd pattern)
├── fixtures.ts            # Playwright test fixtures
├── steps/                 # Legacy class-based step definitions
│   ├── common.steps.ts
│   ├── monitor.steps.ts
│   └── walkthrough.steps.ts
├── test-plans/           # Markdown test specifications
│   ├── TEMPLATE.md
│   ├── monitor-management.md
│   └── data-testid-guide.md
├── helpers/              # Test utilities
│   └── config.ts
├── auth.setup.ts         # Authentication setup
├── full_walkthrough.spec.ts  # Legacy manual tests
└── README.md             # This file
```

### File Purposes

- **`features/`**: Gherkin .feature files are the primary source of truth
- **`steps.ts`**: Main step definition file using createBdd() pattern
- **`fixtures.ts`**: Custom Playwright fixtures for BDD tests
- **`.features-gen/`**: Auto-generated test files (git-ignored, do not edit)
- **`playwright-bdd.config.ts`**: Configuration for BDD test generation

## Best Practices

### BDD-First Development

1. **Start with Gherkin** - Write feature files before implementation
2. **Keep steps reusable** - Write generic steps that work across scenarios
3. **Use parameters** - Leverage {string} and {int} for flexibility
4. **Background for setup** - Use Background for common preconditions
5. **Descriptive scenarios** - Make scenario names clear and specific

### Gherkin Writing Guidelines

```gherkin
# Good - Specific and testable
Scenario: User adds a monitor and verifies it appears in the list
  When I click the "Add Monitor" button
  And I enter "Front Door" as the monitor name
  Then I should see a monitor card with name "Front Door"

# Bad - Vague and untestable
Scenario: Monitor works
  When I do stuff
  Then it works
```

### Step Definition Guidelines

1. **Keep steps simple** - Each step should do one thing
2. **Use data-testid** - Prefer data-testid over CSS selectors
3. **Add meaningful waits** - Wait for specific conditions, not arbitrary timeouts
4. **Reuse existing steps** - Check `npx bddgen export` before creating new steps
5. **Handle state properly** - Clean up state when necessary

### Element Selection Priority

1. **data-testid** (Preferred) - Most reliable
   ```typescript
   page.getByTestId('monitor-card')
   ```

2. **Role-based selectors** - Semantic, accessible
   ```typescript
   page.getByRole('button', { name: /submit/i })
   ```

3. **Text content** - When role isn't available
   ```typescript
   page.getByText('Monitor name')
   ```

4. **Avoid** - CSS selectors, XPath (fragile)

### Test Structure

1. **Arrange** - Set up test preconditions
2. **Act** - Perform the action being tested
3. **Assert** - Verify expected outcomes

### Async/Await

Always use `await` with Playwright actions:
```typescript
// Good
await page.click('button');
await expect(element).toBeVisible();

// Bad
page.click('button'); // Missing await!
```

### Timeouts

Use explicit timeouts for flaky elements:
```typescript
await expect(element).toBeVisible({ timeout: 10000 });
```

### Test Independence

- Each test should be independent
- Don't rely on test execution order
- Clean up after tests if needed

### Descriptive Names

```typescript
// Good
test('User can add a new monitor and verify it appears in the list')

// Bad
test('test1')
```

### Error Messages

Add descriptive error messages:
```typescript
expect(count, 'Should have at least one monitor').toBeGreaterThan(0);
```

## Debugging Tips

### 1. Use UI Mode
```bash
npx playwright test --ui
```

### 2. Use Debug Mode
```bash
npx playwright test --debug
```

### 3. View Traces
```bash
npx playwright show-trace test-results/*/trace.zip
```

### 4. Take Screenshots
```typescript
await page.screenshot({ path: 'debug.png' });
```

### 5. Console Logs
```typescript
console.log('Current URL:', page.url());
console.log('Element count:', await elements.count());
```

## Additional Resources

- [Playwright Documentation](https://playwright.dev)
- [playwright-bdd Documentation](https://vitalets.github.io/playwright-bdd)
- [Gherkin Reference](https://cucumber.io/docs/gherkin/reference/)
- [Test Plans Guide](./test-plans/TEMPLATE.md)
- [data-testid Guide](./test-plans/data-testid-guide.md)

## Contributing

When adding new tests:

1. Follow the established patterns
2. Add data-testid attributes to new components
3. Document test plans for complex features
4. Update this README if adding new patterns
5. Ensure all tests pass before submitting
