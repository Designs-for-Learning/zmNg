/**
 * Encryption Utility
 *
 * Provides AES-GCM encryption for secure storage of sensitive data (like passwords)
 * in environments where native secure storage is not available (e.g., web browser).
 *
 * Uses the Web Crypto API for standard, secure cryptographic operations.
 *
 * Note: On native mobile apps (iOS/Android), we prefer using the Capacitor Secure Storage
 * plugin which uses the device's Keychain/Keystore. This utility is a fallback for web.
 */

import { log } from './logger';

const ENCRYPTION_ALGORITHM = 'AES-GCM';
const KEY_LENGTH = 256;
const IV_LENGTH = 12;
const KEY_SALT_STORAGE_KEY = 'zmng_crypto_salt_v1';
const PBKDF2_SALT = 'zmng-v1';
const PBKDF2_ITERATIONS = 100000;

export const MIN_ENCRYPTED_BYTES = IV_LENGTH + 1;

function getPersistentSalt(): string {
  if (typeof window === 'undefined' || !window.localStorage) {
    return 'zmng-fallback-salt';
  }

  try {
    const existing = window.localStorage.getItem(KEY_SALT_STORAGE_KEY);
    if (existing) {
      return existing;
    }

    const randomBytes = window.crypto.getRandomValues(new Uint8Array(16));
    const salt = btoa(String.fromCharCode(...randomBytes));
    window.localStorage.setItem(KEY_SALT_STORAGE_KEY, salt);
    return salt;
  } catch {
    return 'zmng-fallback-salt';
  }
}

async function deriveKey(keyMaterialString: string, salt: string): Promise<CryptoKey> {
  const keyMaterial = await window.crypto.subtle.importKey(
    'raw',
    new TextEncoder().encode(keyMaterialString),
    'PBKDF2',
    false,
    ['deriveBits', 'deriveKey']
  );

  return window.crypto.subtle.deriveKey(
    {
      name: 'PBKDF2',
      salt: new TextEncoder().encode(salt),
      iterations: PBKDF2_ITERATIONS,
      hash: 'SHA-256',
    },
    keyMaterial,
    { name: ENCRYPTION_ALGORITHM, length: KEY_LENGTH },
    false,
    ['encrypt', 'decrypt']
  );
}

/**
 * Generate a crypto key from a password.
 * Uses device-specific entropy combined with a salt to derive a key.
 * 
 * @returns Promise resolving to a CryptoKey
 */
async function getEncryptionKey(): Promise<CryptoKey> {
  const persistentSalt = getPersistentSalt();
  return deriveKey(persistentSalt, PBKDF2_SALT);
}

async function getLegacyEncryptionKey(): Promise<CryptoKey> {
  const legacyMaterial = `${PBKDF2_SALT}${navigator.userAgent}`;
  return deriveKey(legacyMaterial, PBKDF2_SALT);
}

async function decryptWithKey(encryptedData: string, key: CryptoKey): Promise<string> {
  const combined = Uint8Array.from(atob(encryptedData), (c) => c.charCodeAt(0));

  // Extract IV and ciphertext
  const iv = combined.slice(0, IV_LENGTH);
  const ciphertext = combined.slice(IV_LENGTH);

  const decrypted = await window.crypto.subtle.decrypt(
    {
      name: ENCRYPTION_ALGORITHM,
      iv: iv,
    },
    key,
    ciphertext
  );

  return new TextDecoder().decode(decrypted);
}

/**
 * Encrypt a string value.
 * 
 * @param plaintext - The string to encrypt
 * @returns Base64 encoded string containing IV + Ciphertext
 */
export async function encrypt(plaintext: string): Promise<string> {
  try {
    const key = await getEncryptionKey();
    const iv = window.crypto.getRandomValues(new Uint8Array(IV_LENGTH));
    const encodedText = new TextEncoder().encode(plaintext);

    const ciphertext = await window.crypto.subtle.encrypt(
      {
        name: ENCRYPTION_ALGORITHM,
        iv: iv,
      },
      key,
      encodedText
    );

    // Combine IV and ciphertext, then base64 encode
    const combined = new Uint8Array(iv.length + ciphertext.byteLength);
    combined.set(iv);
    combined.set(new Uint8Array(ciphertext), iv.length);

    return btoa(String.fromCharCode(...combined));
  } catch (error) {
    log.error('Encryption failed', { component: 'Crypto' }, error);
    throw new Error('Failed to encrypt data');
  }
}

/**
 * Decrypt a string value.
 * 
 * @param encryptedData - Base64 encoded string containing IV + Ciphertext
 * @returns The original plaintext string
 */
export async function decrypt(encryptedData: string): Promise<string> {
  try {
    const key = await getEncryptionKey();
    return await decryptWithKey(encryptedData, key);
  } catch (error) {
    log.error('Decryption failed', { component: 'Crypto' }, error);
    throw new Error('Failed to decrypt data');
  }
}

/**
 * Decrypt using the legacy key derivation (pre persistent-salt).
 */
export async function decryptLegacy(encryptedData: string): Promise<string> {
  try {
    const key = await getLegacyEncryptionKey();
    return await decryptWithKey(encryptedData, key);
  } catch (error) {
    log.error('Legacy decryption failed', { component: 'Crypto' }, error);
    throw new Error('Failed to decrypt data');
  }
}

/**
 * Best-effort check for encrypted payloads generated by this module.
 */
export function isProbablyEncryptedPayload(value: string): boolean {
  try {
    const combined = Uint8Array.from(atob(value), (c) => c.charCodeAt(0));
    return combined.length >= MIN_ENCRYPTED_BYTES;
  } catch {
    return false;
  }
}

/**
 * Check if Web Crypto API is available in the current environment.
 */
export function isCryptoAvailable(): boolean {
  return typeof window !== 'undefined' &&
         typeof window.crypto !== 'undefined' &&
         typeof window.crypto.subtle !== 'undefined';
}
